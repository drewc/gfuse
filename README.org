#+TITLE: GFUSE: a Gerbil FUSE interface

* GFUSE for Dummies

I have to make FUSE align with Gerbil and am fairly dumb when it comes to FUSE
itself.

This start out essentially as a log of my trials and errors while trying to
bring FUSE to both a REPL for development and a simple executable for
production.

** Hello! ~examples/hello.ss~

So ~libfuse~ has ~hello.c~, which is a good place to get started. Very simple,
we have a pretend file with pretend contents in the root directory.

We use [[file:doc/ffi.org][Gerbil's FFI interface]].

*** Try ~_main()~

FFI time. Turn ~main()~ into ~_main()~ and let's import that entire C file.

#+begin_src c
int main(int argc, char *argv[]) { int ret = _main(argc, argv); return ret; }
#+end_src

Running the *C* version with ~--help~ tells us that ~-d~ means debug and
forground. We want that. Also because mount requires root, ~allow_other~.

So we'll pretend to run it as follows.

#+begin_src shell
mkdir -p /tmp/gfuse-fest
./hello -d -o allow_other /tmp/gfuse-test
#+end_src

Here's the ~./examples/try-main-hello.ss~.

#+begin_src scheme :tangle ./examples/try-main-hello.ss
(export try-main)
(import :std/foreign :gerbil/gambit/foreign :gerbil/gambit/threads)

(begin-ffi (try-main)
  (c-declare "#include \"hello.c\"")
  (define-c-lambda try-main () int "
char *argv[] = {
   (char*)\"./hello\",
   (char*)\"-d\",
   (char*)\"-o\",
   (char*)\"allow_other\",
   (char*)\"/tmp/gfuse-test\",
   NULL
};

fprintf(stderr, \"gfuse: This is gerbil main! %s\\n\", argv[0]);

int res = _main(5, argv);
___return(res);"))

#+end_src

Let's give it a go!

#+begin_src shell
./build.ss && sudo GERBIL_PATH=$HOME/.gerbil gxi -e "(begin (import :drewc/fuse/examples/try-main-hello) (try-main))" -
#+end_src
#+begin_quote
removed './examples/try-main-hello__0.o1'
removed './examples/try-main-hello__rt.o1'
removed './examples/try-main-hello.ssi'
removed './examples/try-main-hello.ssxi.ss'
... compile examples/try-main-hello
guile: warning: failed to install locale
guile: warning: failed to install locale
... copy examples/try-main-hello__0.o1 to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello__0.o1
... copy examples/try-main-hello__rt.o1 to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello__rt.o1
... copy examples/try-main-hello.ssi to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello.ssi
... copy examples/try-main-hello.ssxi.ss to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello.ssxi.ss
gfuse: This is gerbil main! ./hello
hello: This is main! ./hello
FUSE library version: 3.10.5
nullpath_ok: 0
unique: 2, opcode: INIT (26), nodeid: 0, insize: 56, pid: 0
INIT: 7.34
flags=0x33fffffb
max_readahead=0x00020000
   INIT: 7.31
   flags=0x0040f039
   max_readahead=0x00020000
   max_write=0x00100000
   max_background=0
   congestion_threshold=0
   time_gran=1
   unique: 2, success, outsize: 80
#+end_quote

It just hangs there at the REPL as ~-d~ specifies we don't ~fork()~ a process. But, does it work?

#+begin_src shell
^Z
[1]+  Stopped                 sudo GERBIL_PATH=~drewc/.gerbil gxi -e "(begin (import :drewc/fuse/examples/try-main-hello) (try-main))" -
$ bg
[1]+ sudo GERBIL_PATH=~drewc/.gerbil gxi -e "(begin (import :drewc/fuse/examples/try-main-hello) (try-main))" - &
$ cat /tmp/gfuse-test/hello
unique: 4, opcode: LOOKUP (1), nodeid: 1, insize: 46, pid: 12839
LOOKUP /hello
getattr[NULL] /hello
   NODEID: 2
   unique: 4, success, outsize: 144
unique: 6, opcode: OPEN (14), nodeid: 2, insize: 48, pid: 12839
open flags: 0x8000 /hello
   open[0] flags: 0x8000 /hello
   unique: 6, success, outsize: 32
unique: 8, opcode: READ (15), nodeid: 2, insize: 80, pid: 12839
read[0] 4096 bytes from 0 flags: 0x8000
   read[0] 13 bytes from 0
   unique: 8, success, outsize: 29
Hello World!
unique: 10, opcode: FLUSH (25), nodeid: 2, insize: 64, pid: 12839
   unique: 10, error: -38 (Function not implemented), outsize: 16
unique: 12, opcode: RELEASE (18), nodeid: 2, insize: 64, pid: 0
   unique: 12, success, outsize: 16
$
#+end_src

It does! That's a wonderful first step.

We can get back to the repl by either ~umount~'ing the mountpoint or sending
~-HUP~ to our process.

 1)
     #+begin_src shell
 sudo umount /tmp/gfuse-test
     #+end_src
 2)
     #+begin_src shell
ps -eo pid,args |grep 'try-main' | cut -f1 -d' '| head -1 | xargs kill -HUP
     #+end_src

 That's important as we now have a way to modify and kill/restart things. Yeah!

 A little bit further before we ~fork()~ around.

*** ~first-hello~ Executable

This is quite simple. Essentially we need to prepare, on gerbil's side, the
variables ~argc~ and ~argv~ from a ~(main . args)~ function.

The only reason it's simple is this part comes after the figuring out of how to
do just that. The details are in the first [[#firstHelloExec][~opt.ss~ and ~fuse_opt.h~]] that
follows.

#+begin_src scheme :tangle ./examples/first-hello.ss :noweb yes
(export (import: ../opt) main)
(import :std/foreign :gerbil/gambit/foreign ../opt)

(def (main . args) (%main (fuse_args<-list ["first-hello" args ...])))
(begin-ffi (%main fuse_args*)
  (c-declare "#include \"hello.c\"")
  (c-declare "#include <fuse_opt.h>")
  (define-c-struct fuse_args)
  (define-c-lambda %main (fuse_args*) int "
int res = _main(___arg1->argc, ___arg1->argv);
___return(res);"))
#+end_src

That creates a binary that, when dynmaically loading gerbil/gambit objects,
works great!

#+begin_src shell
$ sudo GERBIL_PATH=$HOME/.gerbil ./bin/first-hello \
         --name="hello-gerbil" --contents=$'Gerbil Noise!\n' -o allow_other /tmp/gfuse-test
hello: This is main! first-hello
$ ls /tmp/gfuse-test/
hello-gerbil
$ cat /tmp/gfuse-test/hello-gerbil
Gerbil Noise!
$ sudo umount /tmp/gfuse-test
$ ls /tmp/gfuse-test/
$
#+end_src


**** ~opt.ss~ and ~fuse_opt.h~
:PROPERTIES:
:CUSTOM_ID: firstHelloExec
:END:


This time we need some C fsckery. We need to create our own ~argc~ and ~argv~ to
pass to main.

The "easy" way is to use what FUSE provides and build on that.

We'll make an FFI struct!


#+begin_quote
#include <fuse_opt.h>

Data Fields
  int 	argc
  char ** 	argv
  int 	allocated
#+end_quote

In gerbil. The free function is in ~_main()~ as well so there you go.

#+begin_src scheme :noweb-ref fuse_args
(c-declare "___SCMOBJ fuse_opt_ffi_free_args (void *ptr) {
     fuse_opt_free_args(ptr);
     return ___FIX (___NO_ERR);
    };
")

(define-c-struct fuse_args
  ((argc . int)
   (argv . (pointer char-string))
   (allocated . int))
  "fuse_opt_ffi_free_args")
;;(c-define-type fuse_args (struct "fuse_args"))
;;(c-define-type fuse_args* (pointer fuse_args))
#+end_src

At the bottom of the ~hello.c~ file there's an init. We'l crib that and malloc
on the heap. We need at least one in the ~argv~ which makes sense if you know
*POSIX*.


#+begin_src c :noweb-ref emulate argv
char *argv[] = {
   ___arg1,
   NULL
};
#+end_src

Make it heapy.

#+begin_src c :noweb-ref struct args
struct fuse_args stack_args = FUSE_ARGS_INIT(1, argv);
struct fuse_args *heap_args;
heap_args = (struct fuse_args *) malloc(sizeof(struct fuse_args));
,*heap_args = stack_args;

#+end_src

And create an init function that does just that.

#+begin_src scheme :noweb yes :noweb-ref fuse_args_init
(define-c-lambda %FUSE_ARGS_INIT (char-string) fuse_args* #<<EOF
  <<emulate argv>>
  <<struct args>>

	/* This seems to be what is needed to init and allocate. */
	if (fuse_opt_parse(heap_args, NULL, NULL, NULL) == -1) {
		___return(NULL);   };
  ___return(heap_args);
EOF
)
#+end_src

How about some ~fuse_arg-ref~'s?

#+begin_src scheme :noweb-ref %fuse_args-ref
(define-c-lambda %fuse_args-ref (fuse_args* int) char-string
  "char* ret = ___arg1->argv[___arg2];
___return(ret);")
#+end_src

#+begin_src scheme :noweb-ref fuse_args-ref
(def (fuse_args-ref fas n)
  (let (limit (fuse_args-argc fas))
    (and (> limit n) (%fuse_args-ref fas n))))

#+end_src

There are now two functions we should FFI with.

First there's ~fuse_opt_insert_arg~ which we'll turn into ~fuse_args-ref-set!~.

#+begin_src scheme :noweb-ref fuse_args-ref
(def (fuse_args-ref-set! fas n v)
  (let (limit (fuse_args-argc fas))
    (if (> n limit) (error "arg index Out of range: ~a >= ~a "
                       n limit)
        (fuse_opt_insert_arg fas n v))))
#+end_src

#+begin_src scheme :noweb-ref fuse_opt_insert_arg
(define-c-lambda fuse_opt_insert_arg (fuse_args* int char-string) int
  "fuse_opt_insert_arg")
#+end_src

There's also ~fuse_opt_add_arg~ which we don't actually require as ~fuse_opt_insert_arg~ calls it but it does make it clear.

#+begin_src scheme :noweb-ref fuse_opt_add_arg
(define-c-lambda fuse_opt_add_arg (fuse_args* char-string) int
  "fuse_opt_add_arg")
#+end_src

Using them we can make a ~fuse_args<-list~ constructor. Aliased as ~list->fuse_args~ for those forwards people.

#+begin_src scheme :noweb-ref fuse_args<-list
(def (fuse_args<-list lst)
  (def fas (%FUSE_ARGS_INIT (car lst)))
  (def n 1)
  (for-each (lambda (fa)
              (set! (fuse_args-ref fas n) fa)
              (set! n (1+ n)))
            (cdr lst))
  fas)
(defalias list->fuse_args fuse_args<-list)
#+end_src

Now just to confuse those forwards thinkers that think end is the result, ~list<-fuse_args~ and ~fuse_args->list~.

#+begin_src scheme :noweb-ref fuse_args->list
(def (fuse_args->list fas)
  (def limit (fuse_args-argc fas))
  (let lst ((n 0))
    (if (= n limit) []
        (cons (fuse_args-ref fas n) (lst (1+ n))))))
(defalias list<-fuse_args fuse_args->list)
#+end_src

It's important to note that our ~set!~ does not modify but rather appends or
prepends at ~pos~.

#+begin_quote
◆ fuse_opt_insert_arg()

int fuse_opt_insert_arg	(
  struct fuse_args * 	args,
  int 	pos,
  const char * 	arg
)

Add an argument at the specified position in a NULL terminated argument vector

Adds the argument to the N-th position. This is useful for adding options at the
beginning of the array which must not come after the special '–' option.

Parameters
  - args	is the structure containing the current argument list
  - pos	is the position at which to add the argument
  - arg	is the new argument to add
Returns
-1 on allocation error, 0 on success
#+end_quote

Keeping that in mind it works.

#+begin_src scheme
> (def args ["car" "-d" "-o" "allow_other" "/tmp/gfuse-test"])
> (def fas (fuse_args<-list args))
> (list<-fuse_args fas)
("car" "-d" "-o" "allow_other" "/tmp/gfuse-test")
#+end_src

***** /File/ ~opt.ss~

All of those things can be placed in a file that will grow to have most of ~fuse_opt.h~ translated.

#+begin_src scheme :tangle ./opt.ss :noweb yes
(export
  %FUSE_ARGS_INIT
  fuse_args
  fuse_args*
  fuse_args-argc
  fuse_args-argv
  fuse_args-allocated
  fuse_args-ref
  fuse_args-ref-set!
  fuse_opt_insert_arg
  fuse_opt_add_arg
  fuse_args<-list list->fuse_args
  fuse_args->list list<-fuse_args)
(import :std/foreign :gerbil/gambit/foreign)

<<fuse_args-ref>>

<<fuse_args->list>>

<<fuse_args<-list>>

(begin-ffi
    (%FUSE_ARGS_INIT
     fuse_opt_add_arg
     %fuse_args-ref
     fuse_opt_insert_arg
     fuse_args fuse_args* (struct fuse_args argc argv allocated)
     )
  (c-declare "#include <fuse_opt.h>")

  <<fuse_args>>

<<fuse_args_init>>

  <<fuse_opt_insert_arg>>

  <<%fuse_args-ref>>)

#+end_src


*** What about ASAP?

*AKA: As Static As Possible*

My dream is to ship a single binary that runs on most any linux x86-64. I think
I can get us there but it's a path full of fun as we do not yet design around
that endpoint.

For starters cloning the ~first-hello.ss~ and trying to ~static-exe:~'ify it
runs into the first error.

#+begin_quote
... compile static exe examples/second-hello -> /home/drewc/me/src/gfuse/./bin/second-hello
,*** ERROR IN "/home/drewc/.gerbil/lib/static/drewc__fuse__examples__second-hello.scm"@241.3 -- C type's name is already defined
,*** ERROR IN std/misc/concurrent-plan#perform-plan/threads__% -- Failure to build
#+end_quote

See, for static files *Gerbil*'s transpiler takes a ~.ss~ module and transforms
it into a ~.scm~ file that no longer relies on *Gerbil* but rather is understood
and built by *Gambit*.

The issue is that *Gambit* refuses to have two *C* types with the same name.

   - We want to spread things out between modules for layout and *REPL* reasons.
   - We want to keep things together for Production and Distribution.

Those two confict somewhat. Let's try to get around it.

After ~grep~'ing the ~./src/gambit~ files for the error I found what is needed
for now.

#+begin_src scheme :noweb-ref extern-c-struct
(define-macro (extern-c-struct name)
  (let ((exists? (assoc name c#c-interface-types)))
    (if exists?
      '(begin)
      `(define-c-struct ,name))))
#+end_src

Let's make a ~second-hello~ and try to be static.

This time we need to copy the ~hello.c~ to the same directory we build the
static exe, which is ~./bin~, and remove the ~main()~ from it as statically we
need another. Beyond that it's still [[#binHelloC][~/hello.c~]].

#+begin_src scheme :tangle ./examples/second-hello.ss :noweb yes
(export (import: ../opt) main futz-struct)
(import :std/foreign :gerbil/gambit/foreign ../opt :gerbil/gambit)

(def (main . args) (%main (fuse_args<-list [(car ##processed-command-line) args ...])))
(begin-ffi (%main fuse_args* futz-struct)
  (c-declare "#include \"hello.c\"")
  (c-declare "#include <fuse_opt.h>")
  <<extern-c-struct>>
  (extern-c-struct fuse_args)
  (define-c-lambda %main (fuse_args*) int "
int res = _main(___arg1->argc, ___arg1->argv);
___return(res);"))
#+end_src

It works!

#+begin_src shell
$ sudo ./bin/second-hello \
    --name="hello-gerbil" --contents=$'Gerbil Noise!\n'\
    -o allow_other /tmp/gfuse-test
$ cat /tmp/gfuse-test/hello-gerbil
Gerbil Noise!
$ sudo umount /tmp/gfuse-test
$ cat /tmp/gfuse-test/hello-gerbil
cat: /tmp/gfuse-test/hello-gerbil: No such file or directory
#+end_src

*** ~gfuse_read~ part I: ~file-contents~

Right now we just pass strings to *C* and it takes care of the rest.

That's not what I desire. Gerbil must feed things!

We'll make it so. First, What does ~hello_read()~ do?.

#+begin_src c
static int hello_read(const char *path, char *buf, size_t size, off_t offset,
		      struct fuse_file_info *fi)
{
	size_t len;
	(void) fi;
	if(strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	len = strlen(options.contents);
	if (offset < len) {
		if (offset + size > len)
			size = len - offset;
		memcpy(buf, options.contents + offset, size);
	} else
		size = 0;

	return size;
}
#+end_src

We'll try and make it simple. No strings but rather ~u8vector~'s, AKA ~bytes~.

All we want to do is copy a vector of bytes to the ~char* buf~. Easy, right?

First attempt, The *C* function calls a *Scheme* function which calls a *C* lambda function.

So first the *C* function.

#+begin_src c :noweb-ref first-hello-read
static int hello_read(const char *path, char *buf, size_t size, off_t offset,
		      struct fuse_file_info *fi)
{
  int ret = gfuse_read((char *)path, buf, size, offset, fi);
  return ret;

};
#+end_src

We'll make it come from a "global" in *Gerbil*.

#+begin_src scheme :noweb-ref first-contents
(define file-contents (string->bytes "This is a byte sized string!\n"))
#+end_src

Now the *Scheme* function. This uses [[file:doc/gambit.org::#the-c-define-special-form][The =c-define= special form]].

#+begin_src scheme :noweb-ref gfuse-read
(define-c-struct fuse_file_info)
(c-define
 (gfuse-read path buf size offset fi)
 (char-string (pointer char) size_t int fuse_file_info*)
 int "gfuse_read" "static"

 (gfuse-read-bytes file-contents path buf size offset fi))
#+end_src

And finally the link back to *C*.

#+begin_src scheme :noweb-ref hello-gfuse-read-bytes
(define-c-lambda gfuse-read-bytes
  (scheme-object char-string (pointer char) size_t int fuse_file_info*)
  int
  "
  ___SCMOBJ bytes = ___arg1;
  char *path= ___arg2;
  char *buf = ___arg3;
	size_t len;
  size_t size = ___arg4;
  int offset = ___arg5;

  (void) ___arg6;

	if(strcmp(path+1, options.filename) != 0)
		___return(-ENOENT);

	len = U8_LEN (bytes);

  fprintf(stderr, \"gfuse: This is gerbil read! %d %d %d \\n\", len, offset, size);
	if (offset < len) {
		if (offset + size > len)
			size = len - offset;
		memcpy(buf, U8_DATA (bytes) + offset, size);
	} else
		size = 0;

	___return(size);
    ")
#+end_src

Trying it like this it sort of works but cuts short.

#+begin_src shell
$ sudo GERBIL_PATH=~drewc/.gerbil gxi \
    -e "(begin (import :drewc/fuse/examples/gfuse-read-hello))" \
    -e '(main "-o" "allow_other" "/tmp/gfuse-test")
$  cat /tmp/gfuse-test/hello
This is a byt$
#+end_src

**** ~getattr~
The reason why is actually simple. I jumped ahead, and before ~hello_read~ is in fact ~hello_getattr~ which returns the length as ~strlen(options.contents)~ which is not right.

#+begin_src c
static int hello_getattr(const char *path, struct stat *stbuf,
			 struct fuse_file_info *fi)
{
	(void) fi;
	int res = 0;

	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path+1, options.filename) == 0) {
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = strlen(options.contents);
	} else
		res = -ENOENT;

	return res;
}
#+end_src

We can simple return the length of our vector.

#+begin_src scheme :noweb-ref hello-gfuse-file-size
(c-define
 (gfuse-file-size) ()
 int "gfuse_file_size" ""
 (u8vector-length file-contents))
#+end_src

... and repeat with that.


#+begin_src c :noweb-ref gfuse-read-getattr
static int hello_getattr(const char *path, struct stat *stbuf,
			 struct fuse_file_info *fi)
{
	(void) fi;
	int res = 0;

	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path+1, options.filename) == 0) {
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = gfuse_file_size();
	} else
		res = -ENOENT;

	return res;
}
#+end_src

Does it work?

#+begin_src shell
$ sudo GERBIL_PATH=~drewc/.gerbil gxi \
    -e "(begin (import :drewc/fuse/examples/gfuse-read-hello))" \
    -e '(main "-o" "allow_other" "/tmp/gfuse-test")'
$ cat /tmp/gfuse-test/hello
This is a byte sized string!
$
#+end_src

Yes! How about a static build? Nope. Fails again on the *C* part.

#+begin_src shell
gfuse-read-hello.c: In function ‘gfuse_read’:
gfuse-read-hello.c:651:23: error: ‘___C_LBL_gfuse_read’ undeclared (first use in this function)
  651 | ___BEGIN_SFUN(___MLBL(___C_LBL_gfuse_read),int ___result)
      |                       ^~~~~~~~~~~~~~~~~~~
#+end_src

Still, works enough to move onto the next step which may be the static build
again.


*** Static Build, Take II

Ok, starting from "nothing", it currently fails.

Here's a command line that fails the same as the ~build.ss~ currently does.

#+begin_src shell
_static_exe () {
    gxc -static -d $(pwd) -g -v -exe \
        -o bin/gfuse-read-hello -gsc-flag -keep-temp \
        -ld-options "$(pkg-config fuse3 --libs)" \
        -cc-options "$(pkg-config fuse3 --cflags)" \
        examples/gfuse-read-hello.ss
}
_static_exe
#+end_src

#+begin_quote
gfuse-read-hello.c: In function ‘gfuse_read’:
gfuse-read-hello.c:651:23: error: ‘___C_LBL_gfuse_read’ undeclared (first use in this function)
  651 | ___BEGIN_SFUN(___MLBL(___C_LBL_gfuse_read),int ___result)
#+end_quote

The ~-g~ and ~-keep-temp~ are there for reference so we can see as a non-static
exe actually works.

#+begin_src shell
_exe () {
    gxc -d $(pwd) -static -v \
        -ld-options "$(pkg-config fuse3 --libs)" \
        -cc-options "$(pkg-config fuse3 --cflags)" \
        examples/gfuse-read-hello.ss
    gxc -d $(pwd) -g -v -exe \
    -o bin/gfuse-read-hello -gsc-flag -keep-temp \
    -ld-options "$(pkg-config fuse3 --libs)" \
    -cc-options "$(pkg-config fuse3 --cflags)"\
    examples/gfuse-read-hello.ss
}
_exe
#+end_src

#+begin_src shell
$ sudo GERBIL_LOADPATH=$(pwd) ./bin/gfuse-read-hello \
    -o allow_other /tmp/gfuse-test/
$ cat /tmp/gfuse-test/hello
This is a byte sized string!
sudo umount /tmp/gfuse-test
#+end_src

So the /trick/ will be to figure it all out.

Let's get rid of the generated files and start from "scratch".

#+begin_src shell
_clean () {
    find examples/ -name 'gfuse-r*.ssi' -or -name 'gf*.scm*' \
        -or -name 'gfuse-*.c' -or -name 'gf*__*.o*'| xargs rm -v
    ls bin/gfuse-read-hello* | xargs rm -v
    find static -name '*gfuse-read*' -exec rm -v {} \;
}
#+end_src

Now do the exe compile and find the difference.

#+begin_src shell
_clean
find . -name '*gfuse-read*' > /tmp/gfrh.old
_exe
find . -name '*gfuse-read*' > /tmp/gfrh.new
diff /tmp/gfrh*
rm -v  /tmp/gfrh*
#+end_src

That diff tells us we have a bunch of generated files.

#+begin_quote
,2d0
< ./examples/gfuse-read-hello__rt.o1
< ./examples/gfuse-read-hello__0.o1
4,9d1
< ./examples/gfuse-read-hello__rt.scm
< ./examples/gfuse-read-hello__0.scm
< ./examples/gfuse-read-hello.ssi
< ./examples/gfuse-read-hello__0.c
< ./static/drewc__fuse__examples__gfuse-read-hello.scm
< ./bin/gfuse-read-hello.scmx
< ./bin/gfuse-read-hello
#+end_quote

They differ all differ in name so let's copy them and try the static exe.

#+begin_src
mkdir /tmp/gfuse-exec
find . -name '*gfuse-read*' -exec cp -v {} /tmp/gfuse-exec \;
#+end_src


#+begin_src shell
_clean
find . -name '*gfuse-read*' > /tmp/gfrh.old
_static_exe
find . -name '*gfuse-read*' > /tmp/gfrh.new
diff /tmp/gfrh*
rm -v  /tmp/gfrh*
#+end_src

This tells us something!

First the compilation before error tells us that ~-static~ does as we do for our ~_exe~ first. which is compile the module.

#+begin_quote
compile /home/drewc/src/gfuse/drewc/fuse/examples/gfuse-read-hello__0.scm
copy static module /home/drewc/src/gfuse/drewc/fuse/examples/gfuse-read-hello__0.scm => /home/drewc/src/gfuse/static/drewc__fuse__examples__gfuse-read-hello.scm
compile /home/drewc/src/gfuse/drewc/fuse/examples/gfuse-read-hello__rt.scm
compile /home/drewc/src/gfuse/drewc/fuse/examples/gfuse-read-hello.ssi
[...]
#+end_quote

And the ~diff~ tells us something as well.

#+begin_quote
2,3d1
< ./examples/gfuse-read-hello__rt.scm
< ./examples/gfuse-read-hello__0.scm
5,8d2
< ./examples/gfuse-read-hello.ssi
< ./static/drewc__fuse__examples__gfuse-read-hello.scm
< ./bin/gfuse-read-hello.scmx
< ./bin/gfuse-read-hello.c
#+end_quote

Let's copy and differentiate!


#+begin_src
mkdir /tmp/gfuse-static
find . -name '*gfuse-read*' -exec cp -v {} /tmp/gfuse-static \;
#+end_src

**** The real ~diff~

What's the diff? The ~.scmx~ is a big start.

#+begin_src shell
$ _gdiff () { _p1="/tmp/gfuse-static/gfuse-read-hello$1"; _p2="/tmp/gfuse-exec/gfuse-read-hello$1"; diff $_p2 $_p1; }
$ _gdiff .ssi
$ _gdiff __0.scm
$ _gdiff __rt.scm
$ _gdiff .scmx
#+end_src
#+begin_quote
2,3c2,17
< (include "/gnu/store/78dzdrv5a4c2rgk2ki058cfp244xfp04-gerbil-unstable-0.16-243-g87c6279b/lib/gerbil/lib/gx-init-exe.scm")
< (_gx#start! "drewc/fuse/examples/gfuse-read-hello__rt" 'drewc/fuse/examples/gfuse-read-hello#main)
---
> (declare (optimize-dead-definitions))
> (include "/gnu/store/78dzdrv5a4c2rgk2ki058cfp244xfp04-gerbil-unstable-0.16-243-g87c6279b/lib/gerbil/lib/static/gx-gambc0.scm")
> (##namespace (""))(declare (gambit-scheme) (block) (core) (inline) (inline-primitives) (inlining-limit 350) (constant-fold) (lambda-lift) (standard-bindings) (extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (optimize-dead-definitions) (generic) (mostly-fixnum-flonum))
> (include "/gnu/store/78dzdrv5a4c2rgk2ki058cfp244xfp04-gerbil-unstable-0.16-243-g87c6279b/lib/gerbil/lib/gx-init-static-exe.scm")
> (##namespace (""))(declare (gambit-scheme) (block) (core) (inline) (inline-primitives) (inlining-limit 350) (constant-fold) (lambda-lift) (standard-bindings) (extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (optimize-dead-definitions) (generic) (mostly-fixnum-flonum))
> (include "/gnu/store/78dzdrv5a4c2rgk2ki058cfp244xfp04-gerbil-unstable-0.16-243-g87c6279b/lib/gerbil/lib/static/gerbil__gambit__ports.scm")
> (##namespace (""))(declare (gambit-scheme) (block) (core) (inline) (inline-primitives) (inlining-limit 350) (constant-fold) (lambda-lift) (standard-bindings) (extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (optimize-dead-definitions) (generic) (mostly-fixnum-flonum))
> (include "/gnu/store/78dzdrv5a4c2rgk2ki058cfp244xfp04-gerbil-unstable-0.16-243-g87c6279b/lib/gerbil/lib/static/gerbil__gambit__random.scm")
> (##namespace (""))(declare (gambit-scheme) (block) (core) (inline) (inline-primitives) (inlining-limit 350) (constant-fold) (lambda-lift) (standard-bindings) (extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (optimize-dead-definitions) (generic) (mostly-fixnum-flonum))
> (include "/gnu/store/78dzdrv5a4c2rgk2ki058cfp244xfp04-gerbil-unstable-0.16-243-g87c6279b/lib/gerbil/lib/static/gerbil__gambit__threads.scm")
> (##namespace (""))(declare (gambit-scheme) (block) (core) (inline) (inline-primitives) (inlining-limit 350) (constant-fold) (lambda-lift) (standard-bindings) (extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (optimize-dead-definitions) (generic) (mostly-fixnum-flonum))
> (include "/home/drewc/src/gfuse/static/drewc__fuse__opt.scm")
> (##namespace (""))(declare (gambit-scheme) (block) (core) (inline) (inline-primitives) (inlining-limit 350) (constant-fold) (lambda-lift) (standard-bindings) (extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (optimize-dead-definitions) (generic) (mostly-fixnum-flonum))
> (include "/home/drewc/src/gfuse/static/drewc__fuse__examples__gfuse-read-hello.scm")
> (##namespace (""))(declare (gambit-scheme) (block) (core) (inline) (inline-primitives) (inlining-limit 350) (constant-fold) (lambda-lift) (standard-bindings) (extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (optimize-dead-definitions) (generic) (mostly-fixnum-flonum))
> (apply drewc/fuse/examples/gfuse-read-hello#main (cdr (command-line)))
#+end_quote


Time to figure it out. While having a break and eating a pear my mind said "what about those ~declare~'ations?".

It turns out that by commenting them out and building I was able to figure out
that ~(optimize-dead-definitions)~ is what the issue is.


**** Deep dive into how static exes compile.

So, here's a way to go about changing the file. This is *NOT* the solution, as
it bloats the exe terribly. At the same time it's useful for hacking, especially
for dummies like me, and there you go.

Essentially, ~sed 's/(optimize-dead-definitions)//g' -i $scmx~ is what happens.

#+begin_src scheme
(def (g-compile-static-exe file)
  (def fn (path-strip-extension file))
  (def scmx (string-append fn ".scmx"))
  (def bin (path-expand (path-strip-directory fn) "./bin/"))
  (def -e (string-append "(include \"" gambcsharp "\")"))
  (def (gxcomp)
    (compile-static-exe
     (string-append fn ".ss")
     [ verbose: #t
       invoke-gsc: #f
       output-file: file keep-scm: #t
     ]))
  (def (gscomp)
    (let* ((proc (open-process
                  [path: (gerbil-gsc)
                   arguments: [ "-:i8,f8,-8,t8" #;"-verbose" "-exe" "-o" bin -cc-ld ... "-e" -e scmx]
                   stdout-redirection: #f]))
         (status (process-status proc)))
    (close-port proc)
    (unless (zero? status)
      (error "Compilation error; gsc exited with nonzero status" status)))
    )
  (gxcomp)
  (shell-command (string-append
                  "sed 's/(optimize-dead-definitions)//g' -i "
                  scmx))
  (gscomp))
#+end_src

**** Make ~(declare (not optimize-dead-definitions))~ to solve!

Though that works, it's not ideal. While saying so in the *Gerbil* chat room,
the master @vyzo mentioned something that this dummy had not yet thought about.

I have another pear to eat for just such an occaision, but nonetheless:

#+begin_quote
it must be the tree shaker
try adding (not optimize-dead-definitions) decl in your module
dont blanket remove it, you'll get horrible bloat
just turn off the tree shaker in modules with ffi upcalls, with the decl
#+end_quote

See? That bloat I mentioned earlier? I did not even check the executable size,
that was me trying to look smart.

So, by simply adding that declaration it now builds!

#+begin_src scheme
(declare (not optimize-dead-definitions))
#+end_src

Test out the build.

#+begin_src shell
$ sudo ./bin/gfuse-read-hello -o allow_other /tmp/gfuse-test/
Password:
$ cat /tmp/gfuse-test/hello
This is a byte sized string!
$ sudo umount /tmp/gfuse-test
#+end_src

**** /File/ ~examples/gfuse-read-hello.ss~

#+begin_src scheme :tangle ./examples/gfuse-read-hello.ss :noweb yes
(export (import: ../opt) main)
(import :std/foreign :gerbil/gambit/foreign ../opt :gerbil/gambit)
(declare (not optimize-dead-definitions))
(def (main . args)
  (%main (fuse_args<-list
          [(car ##processed-command-line) args ...])))

(begin-ffi (%main fuse_args* gfuse-read)
  (namespace ("drewc/fuse/examples/first-read-hello#"
              file-contents))
  (c-declare "#define FUSE_USE_VERSION 31")
  (c-declare "#include <fuse.h>")
  (c-declare "#include <fuse_opt.h>")
  (c-declare "static int gfuse_read(char *, char *, long unsigned int,  int,  struct fuse_file_info *);")
  <<hello-gfuse-file-size>>
  (c-declare "#include \"gfuse_read-hello.c\"")
  <<gfuse-read>>
  <<first-contents>>
  <<extern-c-struct>>
  <<hello-gfuse-read-bytes>>
  (extern-c-struct fuse_args)
  (define-c-lambda %main (fuse_args*) int "
int res = _main(___arg1->argc, ___arg1->argv);
___return(res);"))


#+end_src

*** Make ~--name~ and ~--contents~ work.

We can pass a bytearray. Now the new ~file-name~ and the old ~file-contents~
should be passed as well.

**** ~getopt~ sets ~file-contents~.

We need to turn command line arguments into scheme and then into C.

Here's what ~--help~ tells us.

#+begin_quote
usage: ./bin/gfuse-read-hello [options] <mountpoint>

File-system specific options:
    --name=<s>          Name of the "hello" file
                        (default: "hello")
    --contents=<s>      Contents "hello" file
                        (default "Hello, World!\n")

FUSE options:
    -h   --help            print help
    -V   --version         print version
    -d   -o debug          enable debug output (implies -f)
    -f                     foreground operation
    -s                     disable multi-threaded operation
    -o clone_fd            use separate fuse device fd for each thread
                           (may improve performance)
    -o max_idle_threads    the maximum number of idle worker threads
                           allowed (default: 10)
    -o kernel_cache        cache files in kernel
    -o [no]auto_cache      enable caching based on modification times (off)
    -o umask=M             set file permissions (octal)
    -o uid=N               set file owner
    -o gid=N               set file group
    -o entry_timeout=T     cache timeout for names (1.0s)
    -o negative_timeout=T  cache timeout for deleted names (0.0s)
    -o attr_timeout=T      cache timeout for attributes (1.0s)
    -o ac_attr_timeout=T   auto cache timeout for attributes (attr_timeout)
    -o noforget            never forget cached inodes
    -o remember=T          remember cached inodes for T seconds (0s)
    -o modules=M1[:M2...]  names of modules to push onto filesystem stack
    -o allow_other         allow access by all users
    -o allow_root          allow access by root
    -o auto_unmount        auto unmount on process termination

Options for subdir module:
    -o subdir=DIR           prepend this directory to all paths (mandatory)
    -o [no]rellinks         transform absolute symlinks to relative

Options for iconv module:
    -o from_code=CHARSET   original encoding of file names (default: UTF-8)
    -o to_code=CHARSET     new encoding of the file names (default: UTF-8)

#+end_quote

So here's a ~go~ at it.

We'll ~define~ some foreign variables.

#+begin_src scheme :noweb-ref second-contents-fn
(define file-contents (string->bytes "This is a set! string!\n"))
(define file-name "hello-getopt")
#+end_src

Those should ultimately be ~set!~ from ~getopt-parse~.

#+begin_src scheme :noweb-ref first-go
(def go
  (getopt
   (option '--name "--name"
           help: "Name of the \"hello\" file"
           default: "hello")
   (option '--contents "--contents"
           help: "Contents of the \"hello\" file"
           default: "Hello World!\n")
   (flag '--help "-h" "--help")
   (flag '--version "-V" "--version")
   (flag '-d "-d")
   (flag '-f "-f")
   (flag '-s "-s")
   (option '-o "-o")
   ;;; Not needed for --help
   (optional-argument '<mountpoint>)))
#+end_src

Now with the exceptions of our two options we want to pass the rest onto fuse.

#+begin_src scheme :noweb-ref getopts->fuse

(def (getopts->fuse tbl)
  (def args [])
  (def mp #f)
  (def opts (table->list tbl))
  (def (opt->lst pair)
    (match pair
      ([key . val]
       (let (optk (symbol->string key))
         (cond ((boolean? val) (if val [optk] []))
               ((list? val)
                (let lp ((v val))
                  (if (null? v) v
                      (cons* optk (car v)
                             (lp (cdr v))))))
               (else [optk val]))))))

  (for-each (lambda (pair)
              (match pair
                ([name . val]
                 (cond
                  ((eq? name '<mountpoint>) (set! mp val))
                  ((eq? name '--name) (set! file-name val))
                  ((eq? name '--contents)
                   (set! file-contents
                     (string->bytes val)))
                  (else (push! (opt->lst pair) args))))))
            opts)

  (when mp (push! [mp] args))

  (set! args (reverse! args))
  (append-map (lambda (a) (if (list? a) a [a])) args))

#+end_src

Just with that the ~--contents~ are taken care of.

#+begin_src shell
$ sudo ./bin/gfuse-getopt-hello --contents $'This is the new contents you know \n' -o  allow_other  /tmp/gfuse-test
$ cat /tmp/gfuse-test/hello
This is the new contents you know
$ sudo umount -f /tmp/gfuse-test
#+end_src

**** File name

We already know the size is in ~hello_getattr~.

That's also one place where the name appears. Simply make it
~gfuse_file_name()~;

#+begin_src c :noweb-ref gfuse-getopt-getattr
static int hello_getattr(const char *path, struct stat *stbuf,
			 struct fuse_file_info *fi)
{
	(void) fi;
	int res = 0;
    char* name = gfuse_file_name();

	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path+1, name) == 0) {
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = gfuse_file_size();
	} else
		res = -ENOENT;

	return res;
}
#+end_src


It also needs to be in ~hello_readdir~ and ~hello_open~

#+begin_src c :noweb-ref gfuse-getopt-dir-open
static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
			 off_t offset, struct fuse_file_info *fi,
			 enum fuse_readdir_flags flags)
{
	(void) offset;
	(void) fi;
	(void) flags;

    char* name = gfuse_file_name();

    if (strcmp(path, "/") != 0)
		return -ENOENT;

	filler(buf, ".", NULL, 0, 0);
	filler(buf, "..", NULL, 0, 0);
	filler(buf, name ,NULL, 0, 0);


	return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi)
{

    char* name = gfuse_file_name();
	if (strcmp(path+1, name) != 0)
		return -ENOENT;

	if ((fi->flags & O_ACCMODE) != O_RDONLY)
		return -EACCES;

	return 0;
}
#+end_src

We also need to change the ~gfuse-read-bytes~ C portion so it look for that
correct name.

#+begin_src scheme :noweb-ref gfuse-getopt-read-bytes
(define-c-lambda gfuse-read-bytes
  (scheme-object char-string (pointer char) size_t int fuse_file_info*)
  int
  "
  ___SCMOBJ bytes = ___arg1;
  char *path= ___arg2;
  char *buf = ___arg3;
	size_t len;
  size_t size = ___arg4;
  int offset = ___arg5;

  (void) ___arg6;

  char* name = gfuse_file_name();

	if(strcmp(path+1, name) != 0)
		___return(-ENOENT);

	len = U8_LEN (bytes);

	if (offset < len) {
		if (offset + size > len)
			size = len - offset;
		memcpy(buf, U8_DATA (bytes) + offset, size);
	} else
		size = 0;

	___return(size);
    ")
#+end_src

Now the ~gfuse_file_name()~.

#+begin_src scheme :noweb-ref hello-gfuse-file-name
(c-define
 (gfuse-file-name) ()
  char-string "gfuse_file_name" "" file-name)
#+end_src

And given that it now works!

#+begin_src shell
$ sudo ./bin/gfuse-getopt-hello \
    --name 'hello-gerbil' \
    --contents $'This is the new contents you know \n' \
    -o allow_other /tmp/gfuse-test
$ ls /tmp/gfuse-test/
hello-gerbil
$ cat /tmp/gfuse-test/hello-gerbil
This is the new contents you know
#+end_src


**** /File/ ~examples/gfuse-getopt-hello.ss~

#+begin_src scheme :tangle ./examples/gfuse-getopt-hello.ss :noweb yes
(export (import: ../opt) main)
(import :std/foreign :gerbil/gambit/foreign ../opt :gerbil/gambit
        :std/misc/list :std/getopt :std/srfi/1)
(declare (not optimize-dead-definitions))

<<getopts->fuse>>

<<first-go>>

(def (main . args)
  (def go-args (getopt-parse go args))
  (def fargs (getopts->fuse go-args))
  (%main (fuse_args<-list
          [(car ##processed-command-line) fargs ...])))

(begin-ffi (%main fuse_args* gfuse-read
            file-contents file-name)
  (c-declare "#define FUSE_USE_VERSION 31")
  (c-declare "#include <fuse.h>")
  (c-declare "#include <fuse_opt.h>")
  (c-declare "static int gfuse_read(char *, char *, long unsigned int,  int,  struct fuse_file_info *);")
  <<hello-gfuse-file-size>>
  <<hello-gfuse-file-name>>
  (c-declare "#include \"gfuse_getopt-hello.c\"")
  <<gfuse-read>>
  <<second-contents-fn>>
  <<extern-c-struct>>
  <<gfuse-getopt-read-bytes>>
  (extern-c-struct fuse_args)
  (define-c-lambda %main (fuse_args*) int "
int res = _main(___arg1->argc, ___arg1->argv);
___return(res);"))


#+end_src
**** /File/ ~examples/gfuse_getopt-hello.c~
:PROPERTIES:
:CUSTOM_ID: exFuseGetoptHello
:END:

#+begin_src c :tangle ./examples/gfuse_getopt-hello.c :noweb yes
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU GPLv2.
  See the file COPYING.
,*/

/** @file
 ,*
 ,* minimal example filesystem using high-level API
 ,*
 ,* Compile with:
 ,*
 ,*     gcc -Wall hello.c `pkg-config fuse3 --cflags --libs` -o hello
 ,*
 ,* ## Source code ##
 ,* \include hello.c
 ,*/


#define FUSE_USE_VERSION 31

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <assert.h>

static void *hello_init(struct fuse_conn_info *conn,
			struct fuse_config *cfg)
{
	(void) conn;
  cfg->kernel_cache = 1;
	return NULL;
}

<<gfuse-getopt-getattr>>

<<gfuse-getopt-dir-open>>
<<first-hello-read>>

static const struct fuse_operations hello_oper = {
	.init           = hello_init,
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
};


int _main(int argc, char *argv[])
{
	int ret;
	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);


	/* Parse options */
	if (fuse_opt_parse(&args, NULL, NULL, NULL) == -1) {
		return 1;
    }

	ret = fuse_main(args.argc, args.argv, &hello_oper, NULL);
	fuse_opt_free_args(&args);
	return ret;
}

#+end_src

*** All C -> Scheme!

Last time around we minimized the C file. It's now time to go even further with
that.

We want all functions to be gerbil. Here's what the FS has.

#+begin_src c
static const struct fuse_operations hello_oper = {
	.init           = hello_init,
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
};
#+end_src

We'll use gerbil's structs and methods.

#+begin_src scheme :noweb-ref struct-fuse-operations
(defstruct fuse-operations ())
(set! current-fuse-operations
  (make-parameter (make-fuse-operations)))
#+end_src

Now create a struct instance to use.

#+begin_src scheme :noweb-ref old-hello-oper
(def hello-oper (make-fuse-operations))
(current-fuse-operations hello-oper)
#+end_src

And a *C* function to return it.

#+begin_src scheme :noweb-ref fuse_operations
(c-define
 (current_gfuse_operations) ()
  scheme-object "current_gfuse_operations" ""
  (current-fuse-operations))
#+end_src

**** ~{init}~

#+begin_quote
◆ init
void *(* fuse_operations::init)(struct fuse_conn_info *conn, struct fuse_config *cfg)

Initialize filesystem

The return value will passed in the private_data field of struct fuse_context to
all file operations, and as a parameter to the destroy() method. It overrides
the initial value provided to fuse_main() / fuse_new().
#+end_quote

What are the structs? The ~fuse_config~ seems relevant.

#+begin_src c
static void *hello_init(struct fuse_conn_info *conn,
			struct fuse_config *cfg)
{
	(void) conn;
  cfg->kernel_cache = 1;
	return NULL;
}
#+end_src

But we don't care much about either of them to start with, but we do need to
ensure them and define the kernel_cache.

We do not want to ~free()~ the struct.

#+begin_src scheme :noweb-ref fuse_operations
(c-declare #<<END-C
#ifndef ___HAVE_FFI_NOFREE
#define ___HAVE_FFI_NOFREE
___SCMOBJ ffi_nofree (void *ptr)
{
 return ___FIX (___NO_ERR);
}
#endif
END-C
)
#+end_src

#+begin_src scheme :noweb-ref fuse_operations
(define-c-struct fuse_conn_info () "ffi_nofree")
(define-c-struct fuse_config ((kernel_cache . int))
  "ffi_nofree")
#+end_src

Now the FFI calls a ~C~ function that is created from scheme.

#+begin_src c :noweb-ref gfuse-operations-hello-init :noweb yes
<<scm_fuse_operations>>
___SCMOBJ current_gfuse_operations();
void gfuse_operations_init(long int,  struct fuse_conn_info *, struct fuse_config *);
static void *hello_init(struct fuse_conn_info *conn,
			struct fuse_config *cfg)
{

    fprintf(stderr, "Calling gfuse_operations_init \n");
    fflush(stderr);
    gfuse_operations_init(current_gfuse_operations(), conn, cfg);
    fflush(stderr);
    fprintf(stderr, "Finished gfuse_operations_init \n");
	return NULL;
}
#+end_src

#+begin_src scheme :noweb-ref fuse_operations
(c-define
 (gfuse_operations_init gfo conn cfg) (scheme-object fuse_conn_info* fuse_config*)
  void "gfuse_operations_init" "" (fuse-operations-init gfo conn cfg))
#+end_src

The scheme function sets the cache.

#+begin_src scheme :noweb-ref fuse-operations
(defmethod {init fuse-operations}
  (lambda (self conn cf)
    (set! (fuse_config-kernel_cache cf) 1)
    []))

(set! fuse-operations-init
     (lambda (s c f)
      ;; (display "HERE IN INIT FFS")
       {init s c f}))
#+end_src

In a ~fork()~'d process any attempt to ~display~ hangs. That's important to keep
in mind. Hence the comment. It does work though!


**** ~{readdir}~

There's a pointer to a *C* function, ~fuse_fill_dir_t~.

#+begin_quote
fuse_fill_dir_t

typedef int(* fuse_fill_dir_t) (void *buf, const char *name, const struct stat *stbuf, off_t off, enum fuse_fill_dir_flags flags)

Function to add an entry in a readdir() operation

The off parameter can be any non-zero value that enables the filesystem to identify the current point in the directory stream. It does not need to be the actual physical position. A value of zero is reserved to indicate that seeking in directories is not supported.

Parameters
buf	the buffer passed to the readdir() operation
name	the file name of the directory entry
stbuf	file attributes, can be NULL
off	offset of the next entry or zero
flags	fill flags
Returns
1 if buffer is full, zero otherwise
Definition at line 85 of file fuse.h.
#+end_quote

We can't call that in *Gambit* AFAIK so we'll make a function to call it.

#+begin_src scheme :noweb-ref fuse_operations
(c-define-type fuse_fill_dir_t "fuse_fill_dir_t")
(c-define-type fuse_fill_dir_t* (pointer fuse_fill_dir_t))
(c-define-type stat (struct "stat"))
(c-define-type stat* (pointer stat))
(c-define-type off_t int)
(define-c-struct fuse_file_info () "ffi_nofree")

(define-c-lambda fuse_fill_dir
  (fuse_fill_dir_t (pointer void) char-string stat* off_t int)
  int "
int ret = ___arg1(___arg2, ___arg3, ___arg4, ___arg5, ___arg6);
___return(ret);
")
#+end_src

Now the idea is simple, right? Here's the existing ~hello_readdir~.

#+begin_src c
static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
			 off_t offset, struct fuse_file_info *fi,
			 enum fuse_readdir_flags flags)
{
	(void) offset;
	(void) fi;
	(void) flags;

    char* name = gfuse_file_name();

    if (strcmp(path, "/") != 0)
		return -ENOENT;

	filler(buf, ".", NULL, 0, 0);
	filler(buf, "..", NULL, 0, 0);
	filler(buf, name ,NULL, 0, 0);


	return 0;
}
#+end_src

We'll ignore the file for the default and just return the ~.~ and ~..~

#+begin_src scheme :noweb-ref fuse-operations

(defmethod {readdir fuse-operations}
  (lambda (self path buf fd off fi flags)
    (if (not (string=? path "/")) (-ENOENT)
        (begin
          (fuse_fill_dir fd buf "." #f 0 0)
          (fuse_fill_dir fd buf ".." #f 0 0)
          0))))

(set! fuse-operations-readdir
  (lambda (self p b f o fi fl) {readdir self p b f o fi fl}))

#+end_src

That also requires ~-ENOENT~.

#+begin_src scheme :noweb-ref fuse_operations
(define-c-lambda -ENOENT () int "___return(-ENOENT);")
#+end_src

Now the *C* interface.

#+begin_src scheme :noweb-ref fuse_operations
(c-define
 (gfuse_operations_readdir gfo path buff fd off fi flags)
 (scheme-object char-string (pointer void)
                fuse_fill_dir_t off_t fuse_file_info* int)
  int "gfuse_operations_readdir" ""
  (fuse-operations-readdir gfo path buff fd off fi flags))
#+end_src

#+begin_src c :noweb-ref gfuse-operations-readdir
int gfuse_operations_readdir (___SCMOBJ,char*,void*,fuse_fill_dir_t ,int,struct fuse_file_info*,int);

static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi, enum fuse_readdir_flags flags)
{
  int ret = gfuse_operations_readdir(current_gfuse_operations(),
                                     (char *) path, buf, filler, offset, fi, flags);
  return ret;
}
#+end_src

In our ~hello_readdir~ there should also be a file. We'll make a substruct and try a next-method.

#+begin_src scheme :noweb-ref hello-oper
(defstruct (hello-fuse-operations fuse-operations) ())
(def hello-oper (make-hello-fuse-operations))
(current-fuse-operations hello-oper)
#+end_src

Now a submethod.

#+begin_src scheme :noweb-ref fuse-operations

(defmethod {readdir hello-fuse-operations}
  (lambda (self path buf fd off fi flags)
    (def ret (@next-method self path buf fd off fi flags))
    (if (not (zero? ret)) ret
        (begin (fuse_fill_dir fd buf file-name #f 0 0)
          0))))

#+end_src

It works.

#+begin_src shell
$ sudo ./bin/gfuse-operations-hello --name 'hello-gerbil' --contents $'This is the new contents you know \n' -o allow_other  /tmp/gfuse-test
$ ls /tmp/gfuse-test/ -a
./  ../  hello-gerbil
$ cat /tmp/gfuse-test/hello-gerbil
This is the new contents you know
$ sudo umount -f /tmp/gfuse-test
#+end_src

**** ~gfuse_read~ part II AKA ~{read}~

#+begin_src c :noweb-ref c-gfuse-operations-read

static int gfuse_operations_read(___SCMOBJ, char *path, char *buf, long unsigned int,  int, struct fuse_file_info*);

static int hello_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi)
{
  int ret = gfuse_operations_read(current_gfuse_operations(),
                       (char *)path, buf, size, offset, fi);
  return ret;

};
#+end_src

#+begin_src scheme :noweb-ref fuse_operations

(c-define
 (gfuse_operations_read gfo path buf size offset fi)
 (scheme-object char-string (pointer char) size_t off_t fuse_file_info*)
 int "gfuse_operations_read" ""
 (fuse-operations-read gfo path buf size offset fi))
#+end_src

For the default we'll simply say it does not exist.

#+begin_src scheme :noweb-ref fuse-operations
(defmethod {read fuse-operations}
  (lambda _ (-ENOENT)))
(set! fuse-operations-read
  (lambda (gfo path buf size offset fi)
    {read gfo path buf size offset fi}))
#+end_src


#+begin_src scheme :tangle ./examples/gfuse-operations-hello.ss :noweb yes
(export (import: ../opt) main)
(import :std/foreign :gerbil/gambit/foreign ../opt :gerbil/gambit
        :std/misc/list :std/getopt :std/srfi/1)
(declare (not optimize-dead-definitions))

(begin-ffi (%main fuse_args* gfuse-read
            file-contents file-name fuse-operations-init
            fuse_config fuse_config* (struct fuse_config kernel_cache)
            current-fuse-operations fuse_fill_dir -ENOENT
            fuse-operations-readdir fuse-operations-read)
(c-declare "#define FUSE_USE_VERSION 31")
(c-declare "#include <fuse.h>")
(c-declare "#include <fuse_opt.h>")

<<hello-gfuse-file-size>>

<<hello-gfuse-file-name>>

(c-declare "#include \"gfuse_operations-hello.c\"")

<<second-contents-fn>>
<<extern-c-struct>>

(extern-c-struct fuse_args)

<<fuse_operations>>

(define-c-lambda %main (fuse_args*) int "
int res = _main(___arg1->argc, ___arg1->argv);
___return(res);")

) ;; /begin-ffi

<<getopts->fuse>>

<<first-go>>

<<struct-fuse-operations>>

<<hello-oper>>

<<fuse-operations>>

(def (main . args)
  (def go-args (getopt-parse go args))
  (def fargs (getopts->fuse go-args))


  (%main (fuse_args<-list
          [(car ##processed-command-line) fargs ...])))




#+end_src



**** /File/ ~examples/gfuse_operations-hello.c~
:PROPERTIES:
:CUSTOM_ID: exFuseGetoptHello
:END:

#+begin_src c :tangle ./examples/gfuse_operations-hello.c :noweb yes
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU GPLv2.
  See the file COPYING.
,*/

/** @file
 ,*
 ,* minimal example filesystem using high-level API
 ,*
 ,* Compile with:
 ,*
 ,*     gcc -Wall hello.c `pkg-config fuse3 --cflags --libs` -o hello
 ,*
 ,* ## Source code ##
 ,* \include hello.c
 ,*/


#define FUSE_USE_VERSION 31

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <assert.h>
#include <unistd.h>

<<gfuse-operations-hello-init>>

<<gfuse-getopt-getattr>>

<<gfuse-operations-readdir>>

static int hello_open(const char *path, struct fuse_file_info *fi)
{

    char* name = gfuse_file_name();
	if (strcmp(path+1, name) != 0)
		return -ENOENT;

	if ((fi->flags & O_ACCMODE) != O_RDONLY)
		return -EACCES;

	return 0;
}
<<c-gfuse-operations-read>>

static const struct fuse_operations hello_oper = {
	.init           = hello_init,
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
};

/*    /\* int out = open("cout.log", O_RDWR|O_CREAT|O_APPEND, 0600); *\/ */
/*    /\*  if (-1 == out) { perror("opening cout.log"); return 255; } *\/ */

/*      int err = open("cerr.log", O_RDWR|O_CREAT|O_APPEND, 0600); */
/*      if (-1 == err) { perror("opening cerr.log"); return 255; } */

/*    /\*  int save_out = dup(fileno(stdout)); *\/ */
/*      int save_err = dup(fileno(stderr)); */

/*    /\*  if (-1 == dup2(out, fileno(stdout))) { perror("cannot redirect stdout"); return 255; } *\/ */
/*      if (-1 == dup2(err, fileno(stderr))) { perror("cannot redirect stderr"); return 255; } */

int _main(int argc, char *argv[])
{
	int ret;
	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);


	/* Parse options */
	if (fuse_opt_parse(&args, NULL, NULL, NULL) == -1) {
		return 1;
    }

	ret = fuse_main(args.argc, args.argv, &hello_oper, NULL);
	fuse_opt_free_args(&args);
	return ret;
}

#+end_src

*** /File/ ~examples/gfuse_read-hello.c~
:PROPERTIES:
:CUSTOM_ID: exFuseReadHello
:END:

#+begin_src c :tangle ./examples/gfuse_read-hello.c :noweb yes
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU GPLv2.
  See the file COPYING.
,*/

/** @file
 ,*
 ,* minimal example filesystem using high-level API
 ,*
 ,* Compile with:
 ,*
 ,*     gcc -Wall hello.c `pkg-config fuse3 --cflags --libs` -o hello
 ,*
 ,* ## Source code ##
 ,* \include hello.c
 ,*/


#define FUSE_USE_VERSION 31

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <assert.h>

/*
 ,* Command line options
 ,*
 ,* We can't set default values for the char* fields here because
 ,* fuse_opt_parse would attempt to free() them when the user specifies
 ,* different values on the command line.
 ,*/
static struct options {
	const char *filename;
	const char *contents;
	int show_help;
} options;

#define OPTION(t, p)                           \
    { t, offsetof(struct options, p), 1 }
static const struct fuse_opt option_spec[] = {
	OPTION("--name=%s", filename),
	OPTION("--contents=%s", contents),
	OPTION("-h", show_help),
	OPTION("--help", show_help),
	FUSE_OPT_END
};

static void *hello_init(struct fuse_conn_info *conn,
			struct fuse_config *cfg)
{
	(void) conn;
  cfg->kernel_cache = 1;
	return NULL;
}

<<gfuse-read-getattr>>

static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
			 off_t offset, struct fuse_file_info *fi,
			 enum fuse_readdir_flags flags)
{
	(void) offset;
	(void) fi;
	(void) flags;

	if (strcmp(path, "/") != 0)
		return -ENOENT;

	filler(buf, ".", NULL, 0, 0);
	filler(buf, "..", NULL, 0, 0);
	filler(buf, options.filename, NULL, 0, 0);

	return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi)
{
	if (strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	if ((fi->flags & O_ACCMODE) != O_RDONLY)
		return -EACCES;

	return 0;
}

<<first-hello-read>>

static const struct fuse_operations hello_oper = {
	.init           = hello_init,
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
};

static void show_help(const char *progname)
{
	printf("usage: %s [options] <mountpoint>\n\n", progname);
	printf("File-system specific options:\n"
	       "    --name=<s>          Name of the \"hello\" file\n"
	       "                        (default: \"hello\")\n"
	       "    --contents=<s>      Contents \"hello\" file\n"
	       "                        (default \"Hello, World!\\n\")\n"
	       "\n");
}

int _main(int argc, char *argv[])
{
	int ret;
	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);

	/* Set defaults -- we have to use strdup so that
	   fuse_opt_parse can free the defaults if other
	   values are specified */
	options.filename = strdup("hello");
	options.contents = strdup("Hello World!\n");


	/* Parse options */
	if (fuse_opt_parse(&args, &options, option_spec, NULL) == -1) {
		return 1;
    }

	/* When --help is specified, first print our own file-system
	   specific help text, then signal fuse_main to show
	   additional help (by adding `--help` to the options again)
	   without usage: line (by setting argv[0] to the empty
	   string) */
	if (options.show_help) {
		show_help(argv[0]);
		assert(fuse_opt_add_arg(&args, "--help") == 0);
		args.argv[0][0] = '\0';
	}

	ret = fuse_main(args.argc, args.argv, &hello_oper, NULL);
	fuse_opt_free_args(&args);
	return ret;
}

#+end_src

*** /File/ ~bin/hello.c~
:PROPERTIES:
:CUSTOM_ID: binHelloC
:END:

#+begin_src c :tangle ./bin/hello.c
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU GPLv2.
  See the file COPYING.
,*/

/** @file
 ,*
 ,* minimal example filesystem using high-level API
 ,*
 ,* Compile with:
 ,*
 ,*     gcc -Wall hello.c `pkg-config fuse3 --cflags --libs` -o hello
 ,*
 ,* ## Source code ##
 ,* \include hello.c
 ,*/


#define FUSE_USE_VERSION 31

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <assert.h>

/*
 ,* Command line options
 ,*
 ,* We can't set default values for the char* fields here because
 ,* fuse_opt_parse would attempt to free() them when the user specifies
 ,* different values on the command line.
 ,*/
static struct options {
	const char *filename;
	const char *contents;
	int show_help;
} options;

#define OPTION(t, p)                           \
    { t, offsetof(struct options, p), 1 }
static const struct fuse_opt option_spec[] = {
	OPTION("--name=%s", filename),
	OPTION("--contents=%s", contents),
	OPTION("-h", show_help),
	OPTION("--help", show_help),
	FUSE_OPT_END
};

static void *hello_init(struct fuse_conn_info *conn,
			struct fuse_config *cfg)
{
	(void) conn;
  cfg->kernel_cache = 1;
	return NULL;
}

static int hello_getattr(const char *path, struct stat *stbuf,
			 struct fuse_file_info *fi)
{
	(void) fi;
	int res = 0;

	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path+1, options.filename) == 0) {
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = strlen(options.contents);
	} else
		res = -ENOENT;

	return res;
}

static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
			 off_t offset, struct fuse_file_info *fi,
			 enum fuse_readdir_flags flags)
{
	(void) offset;
	(void) fi;
	(void) flags;

	if (strcmp(path, "/") != 0)
		return -ENOENT;

	filler(buf, ".", NULL, 0, 0);
	filler(buf, "..", NULL, 0, 0);
	filler(buf, options.filename, NULL, 0, 0);

	return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi)
{
	if (strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	if ((fi->flags & O_ACCMODE) != O_RDONLY)
		return -EACCES;

	return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset,
		      struct fuse_file_info *fi)
{
	size_t len;
	(void) fi;
	if(strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	len = strlen(options.contents);
	if (offset < len) {
		if (offset + size > len)
			size = len - offset;
		memcpy(buf, options.contents + offset, size);
	} else
		size = 0;

	return size;
}

static const struct fuse_operations hello_oper = {
	.init           = hello_init,
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
};

static void show_help(const char *progname)
{
	printf("usage: %s [options] <mountpoint>\n\n", progname);
	printf("File-system specific options:\n"
	       "    --name=<s>          Name of the \"hello\" file\n"
	       "                        (default: \"hello\")\n"
	       "    --contents=<s>      Contents \"hello\" file\n"
	       "                        (default \"Hello, World!\\n\")\n"
	       "\n");
}

int _main(int argc, char *argv[])
{
	int ret;
	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);

	/* Set defaults -- we have to use strdup so that
	   fuse_opt_parse can free the defaults if other
	   values are specified */
	options.filename = strdup("hello");
	options.contents = strdup("Hello World!\n");


	/* Parse options */
	if (fuse_opt_parse(&args, &options, option_spec, NULL) == -1) {
		return 1;
    }

	/* When --help is specified, first print our own file-system
	   specific help text, then signal fuse_main to show
	   additional help (by adding `--help` to the options again)
	   without usage: line (by setting argv[0] to the empty
	   string) */
	if (options.show_help) {
		show_help(argv[0]);
		assert(fuse_opt_add_arg(&args, "--help") == 0);
		args.argv[0][0] = '\0';
	}

	ret = fuse_main(args.argc, args.argv, &hello_oper, NULL);
	fuse_opt_free_args(&args);
	return ret;
}

#+end_src

*** /File/ ~examples/hello.c~

#+begin_src c :tangle ./examples/hello.c
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU GPLv2.
  See the file COPYING.
,*/

/** @file
 ,*
 ,* minimal example filesystem using high-level API
 ,*
 ,* Compile with:
 ,*
 ,*     gcc -Wall hello.c `pkg-config fuse3 --cflags --libs` -o hello
 ,*
 ,* ## Source code ##
 ,* \include hello.c
 ,*/


#define FUSE_USE_VERSION 31

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <assert.h>

/*
 ,* Command line options
 ,*
 ,* We can't set default values for the char* fields here because
 ,* fuse_opt_parse would attempt to free() them when the user specifies
 ,* different values on the command line.
 ,*/
static struct options {
	const char *filename;
	const char *contents;
	int show_help;
} options;

#define OPTION(t, p)                           \
    { t, offsetof(struct options, p), 1 }
static const struct fuse_opt option_spec[] = {
	OPTION("--name=%s", filename),
	OPTION("--contents=%s", contents),
	OPTION("-h", show_help),
	OPTION("--help", show_help),
	FUSE_OPT_END
};

static void *hello_init(struct fuse_conn_info *conn,
			struct fuse_config *cfg)
{
	(void) conn;
cfg->kernel_cache = 1;
	return NULL;
}

static int hello_getattr(const char *path, struct stat *stbuf,
			 struct fuse_file_info *fi)
{
	(void) fi;
	int res = 0;

	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path+1, options.filename) == 0) {
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = strlen(options.contents);
	} else
		res = -ENOENT;

	return res;
}

static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
			 off_t offset, struct fuse_file_info *fi,
			 enum fuse_readdir_flags flags)
{
	(void) offset;
	(void) fi;
	(void) flags;

	if (strcmp(path, "/") != 0)
		return -ENOENT;

	filler(buf, ".", NULL, 0, 0);
	filler(buf, "..", NULL, 0, 0);
	filler(buf, options.filename, NULL, 0, 0);

	return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi)
{
	if (strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	if ((fi->flags & O_ACCMODE) != O_RDONLY)
		return -EACCES;

	return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset,
		      struct fuse_file_info *fi)
{
	size_t len;
	(void) fi;
	if(strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	len = strlen(options.contents);
	if (offset < len) {
		if (offset + size > len)
			size = len - offset;
		memcpy(buf, options.contents + offset, size);
	} else
		size = 0;

	return size;
}

static const struct fuse_operations hello_oper = {
	.init           = hello_init,
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
};

static void show_help(const char *progname)
{
	printf("usage: %s [options] <mountpoint>\n\n", progname);
	printf("File-system specific options:\n"
	       "    --name=<s>          Name of the \"hello\" file\n"
	       "                        (default: \"hello\")\n"
	       "    --contents=<s>      Contents \"hello\" file\n"
	       "                        (default \"Hello, World!\\n\")\n"
	       "\n");
}

int _main(int argc, char *argv[])
{
	int ret;
	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);

	/* Set defaults -- we have to use strdup so that
	   fuse_opt_parse can free the defaults if other
	   values are specified */
	options.filename = strdup("hello");
	options.contents = strdup("Hello World!\n");


	/* Parse options */
	if (fuse_opt_parse(&args, &options, option_spec, NULL) == -1) {
		return 1;
    }

  fprintf(stderr, "hello: This is main! %s\n", argv[0]);
	/* When --help is specified, first print our own file-system
	   specific help text, then signal fuse_main to show
	   additional help (by adding `--help` to the options again)
	   without usage: line (by setting argv[0] to the empty
	   string) */
	if (options.show_help) {
		show_help(argv[0]);
		assert(fuse_opt_add_arg(&args, "--help") == 0);
		args.argv[0][0] = '\0';
	}

	ret = fuse_main(args.argc, args.argv, &hello_oper, NULL);
	fuse_opt_free_args(&args);
	return ret;
}


int main(int argc, char *argv[]) { int ret = _main(argc, argv); return ret; }
#+end_src


** The ~c2ffi~ generator

#+begin_src c :tangle gfuse.h
#define FUSE_USE_VERSION 31

#include <fuse.h>
#+end_src

#+begin_src shell :tangle ./bin/c2ffi-libfuse :shebang #!/usr/bin/env bash
_file=${1:-"c2ffi-libfuse.ss"}
_h=${1:-"gfuse.h"}

echo '(export #t)' > $_file

_cfile=`mktemp`
_fusedir=$(pkg-config --cflags-only-I fuse3 | sed 's/^-I//g')

echo "(def c2ffi-libfuse '(" >> $_file

c2ffi -D sexp -i "$_fusedir" $_h >> $_file
echo "))" >> $_file
#+end_src

#+RESULTS:

* Gerbil lib

#+begin_src gerbil :tangle gerbil.pkg
(package: drewc/fuse)
#+end_src

#+begin_src gerbil :tangle build.ss :shebang #!/usr/bin/env gxi
(import :std/build-script :std/make
        :gerbil/gambit/ports :gerbil/compiler/driver)

(def libs "fuse3")
(def gerbil-path (getenv "GERBIL_PATH" "~/.gerbil"))
(def gerbil-home (getenv "GERBIL_HOME" gxc#default-gerbil-home))

(def srcdir (path-directory (this-source-file)))
(def libdir (path-expand "lib" gerbil-path))
(def bindir (path-expand "bin" gerbil-path))
(def statdir (path-expand "static" libdir))
(def gerbil-gsc std/make#gerbil-gsc)
(def gambcsharp (path-expand "lib/static/gx-gambc#.scm" gerbil-home))

(def (fgxc fn . rest)
  (cons*
   gxc: fn
   "-cc-options"
   (pkg-config-cflags libs)
   "-ld-options"
   (pkg-config-libs libs)
   rest))

(def -cc-ld
  (list "-cc-options" (pkg-config-cflags libs) "-ld-options" (pkg-config-libs libs)))

(def (force-outputs) (force-output (current-error-port)) (force-output))
(def (message . lst) (apply displayln lst) (force-outputs))

(def (copy-compiled file)
  (def libpath (path-expand (string-append "drewc/fuse/" file) libdir))
  (create-directory* (path-directory libpath))
  (when (file-exists? file)
  (message "... copy " file " to " libpath)

  (when (file-exists? libpath)
    (delete-file libpath))
  (copy-file file libpath)))

(def (copy-static file)
  (def spath (path-expand file statdir))
  (def fpath (path-expand file (path-expand "static/" (path-directory (this-source-file)))))
  (message "... copy static include " file)
  (when (file-exists? spath)
    (delete-file spath))
  (copy-file fpath spath))

(def (g-compile-static-exe file)
  (def fn (path-strip-extension file))
  (def scmx (string-append fn ".scmx"))
  (def bin (path-expand (path-strip-directory fn) "./bin/"))
  (def -e (string-append "(include \"" gambcsharp "\")"))
  (def (gxcomp)
    (compile-static-exe
     (string-append fn ".ss")
     [ verbose: #t
       invoke-gsc: #f
       output-file: file keep-scm: #t
     ]))
  (def (gscomp)
    (let* ((proc (open-process
                  [path: (gerbil-gsc)
                   arguments: [ "-:i8,f8,-8,t8" #;"-verbose" "-exe" "-o" bin -cc-ld ... "-e" -e scmx]
                   stdout-redirection: #f]))
         (status (process-status proc)))
    (close-port proc)
    (unless (zero? status)
      (error "Compilation error; gsc exited with nonzero status" status)))
    )
  (gxcomp)
  (shell-command (string-append
                  "sed 's/(optimize-dead-definitions)//g' -i "
                  scmx))
  (gscomp))




(def (premade path)
  (def posts
    '("__0.o1"
      "__1.o1"
      "__rt.o1"
      ".ssi"
      ".ssxi.ss"))
  (def files (map (cut string-append path <>) posts))

  (map (cut copy-compiled <>) files))

(def (make-clean)
  (shell-command "find . -name '*__*.o*' -exec rm -v {} \\;")
  (shell-command "find . -name '*.ssi' -exec rm -v {} \\;")
  (shell-command "find . -name '*.ssxi.ss' -exec rm -v {} \\;")
  (shell-command "find . -type d -name 'static' -exec rm -rv {} \\;"))

(def (local-build)
  (defbuild-script
    `((gxc: "getopt")                                 ; "c2ffi-libfuse"
      ,(fgxc "opt")
      ;; ,(fgxc "examples/try-main-hello")
      ;; ,(fgxc "examples/first-hello")
      ;; ,(fgxc "examples/second-hello")
      ;; ,(fgxc "examples/gfuse-read-hello")
      ;; ,(fgxc "examples/gfuse-getopt-hello")
      ,(fgxc "examples/gfuse-operations-hello")
       ;; ,(let (libs (cddr (fgxc "asd")))
       ;;   ;; (displayln " Libs ~a" libs)
       ;;   `(gxc: "examples/gfuse-read-hello"
       ;;          ["-s"] "-keep-temp" ,@libs))


             ;  '("-s" "-gsc-flag" "-keep-temp"))
                                        ;,(fgxc "examples/first-hello-exe")
      #;(gxc: "libfuse"
      "-cc-options"                     ;
      ,(pkg-config-cflags libs)         ;
      "-ld-options"                     ;
      ,(pkg-config-libs libs)           ;
      )
      )
    verbose: 1
    libdir: (path-directory (this-source-file)))

  (main))

(def (build-exes)
  (defbuild-script
    `((exe: ,@(cdr (fgxc "examples/first-hello")))
      ;(static-exe:(cdr (fgxc "examples/second-hello")))
      ;; (static-exe: "examples/second-hello" ,@-cc-ld)
      ;; (static-exe: "examples/gfuse-read-hello" ,@-cc-ld)
      ;; (static-exe: "examples/gfuse-getopt-hello" ,@-cc-ld)
      (static-exe: "examples/gfuse-operations-hello" ,@-cc-ld)
      #;(static-exe: ,@(cdr (fgxc "examples/gfuse-read-hello"
                                "-flat")))
      )
    verbose: 1
    libdir: (path-directory (this-source-file))
    bindir: (path-expand "bin/" (path-directory (this-source-file))))
  (main))

(def (make-install)
 (premade "getopt")
 (premade "opt")
 ;; (premade "examples/try-main-hello")
 ;; (premade "examples/first-hello")
 ;; (premade "examples/second-hello")
 ;; (premade "examples/gfuse-read-hello")
 ;; (premade "examples/gfuse-getopt-hello")
 (premade "examples/gfuse-operations-hello")
 (for-each copy-static
           (directory-files
            (path-expand "static/" (path-directory (this-source-file))))))


(def (main . args)
  (parameterize ((current-directory srcdir))
  (if (and (pair? args) (equal? (car args) "clean"))
    (make-clean)
    (begin
      (make-clean)
      (local-build)
      (make-install)
      ;; (g-compile-static-exe "examples/gfuse-read-hello")
      (build-exes)
      (make-install)))))

#+end_src
#+begin_src
#+end_src
