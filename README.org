#+TITLE: GFUSE: a Gerbil FUSE interface

* GFUSE for Dummies

I have to make FUSE align with Gerbil and am fairly dumb when it comes to FUSE
itself.

This start out essentially as a log of my trials and errors while trying to
bring FUSE to both a REPL for development and a simple executable for
production.

** Hello! ~examples/hello.ss~

So ~libfuse~ has ~hello.c~, which is a good place to get started. Very simple,
we have a pretend file with pretend contents in the root directory.

We use [[file:doc/ffi.org][Gerbil's FFI interface]].

*** Try ~_main()~

FFI time. Turn ~main()~ into ~_main()~ and let's import that entire C file.

#+begin_src c
int main(int argc, char *argv[]) { int ret = _main(argc, argv); return ret; }
#+end_src

Running the *C* version with ~--help~ tells us that ~-d~ means debug and
forground. We want that. Also because mount requires root, ~allow_other~.

So we'll pretend to run it as follows.

#+begin_src shell
mkdir -p /tmp/gfuse-fest
./hello -d -o allow_other /tmp/gfuse-test
#+end_src

Here's the ~./examples/try-main-hello.ss~.

#+begin_src scheme :tangle ./examples/try-main-hello.ss
(export try-main)
(import :std/foreign :gerbil/gambit/foreign :gerbil/gambit/threads)

(begin-ffi (try-main)
  (c-declare "#include \"hello.c\"")
  (define-c-lambda try-main () int "
char *argv[] = {
   (char*)\"./hello\",
   (char*)\"-d\",
   (char*)\"-o\",
   (char*)\"allow_other\",
   (char*)\"/tmp/gfuse-test\",
   NULL
};

fprintf(stderr, \"gfuse: This is gerbil main! %s\\n\", argv[0]);

int res = _main(5, argv);
___return(res);"))

#+end_src

Let's give it a go!

#+begin_src shell
./build.ss && sudo GERBIL_PATH=$HOME/.gerbil gxi -e "(begin (import :drewc/fuse/examples/try-main-hello) (try-main))" -
#+end_src
#+begin_quote
removed './examples/try-main-hello__0.o1'
removed './examples/try-main-hello__rt.o1'
removed './examples/try-main-hello.ssi'
removed './examples/try-main-hello.ssxi.ss'
... compile examples/try-main-hello
guile: warning: failed to install locale
guile: warning: failed to install locale
... copy examples/try-main-hello__0.o1 to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello__0.o1
... copy examples/try-main-hello__rt.o1 to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello__rt.o1
... copy examples/try-main-hello.ssi to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello.ssi
... copy examples/try-main-hello.ssxi.ss to ~/.gerbil/lib/drewc/fuse/examples/try-main-hello.ssxi.ss
gfuse: This is gerbil main! ./hello
hello: This is main! ./hello
FUSE library version: 3.10.5
nullpath_ok: 0
unique: 2, opcode: INIT (26), nodeid: 0, insize: 56, pid: 0
INIT: 7.34
flags=0x33fffffb
max_readahead=0x00020000
   INIT: 7.31
   flags=0x0040f039
   max_readahead=0x00020000
   max_write=0x00100000
   max_background=0
   congestion_threshold=0
   time_gran=1
   unique: 2, success, outsize: 80
#+end_quote

It just hangs there at the REPL as ~-d~ specifies we don't ~fork()~ a process. But, does it work?

#+begin_src shell
^Z
[1]+  Stopped                 sudo GERBIL_PATH=~drewc/.gerbil gxi -e "(begin (import :drewc/fuse/examples/try-main-hello) (try-main))" -
$ bg
[1]+ sudo GERBIL_PATH=~drewc/.gerbil gxi -e "(begin (import :drewc/fuse/examples/try-main-hello) (try-main))" - &
$ cat /tmp/gfuse-test/hello
unique: 4, opcode: LOOKUP (1), nodeid: 1, insize: 46, pid: 12839
LOOKUP /hello
getattr[NULL] /hello
   NODEID: 2
   unique: 4, success, outsize: 144
unique: 6, opcode: OPEN (14), nodeid: 2, insize: 48, pid: 12839
open flags: 0x8000 /hello
   open[0] flags: 0x8000 /hello
   unique: 6, success, outsize: 32
unique: 8, opcode: READ (15), nodeid: 2, insize: 80, pid: 12839
read[0] 4096 bytes from 0 flags: 0x8000
   read[0] 13 bytes from 0
   unique: 8, success, outsize: 29
Hello World!
unique: 10, opcode: FLUSH (25), nodeid: 2, insize: 64, pid: 12839
   unique: 10, error: -38 (Function not implemented), outsize: 16
unique: 12, opcode: RELEASE (18), nodeid: 2, insize: 64, pid: 0
   unique: 12, success, outsize: 16
$
#+end_src

It does! That's a wonderful first step.

We can get back to the repl by either ~umount~'ing the mountpoint or sending
~-HUP~ to our process.

 1)
     #+begin_src shell
 sudo umount /tmp/gfuse-test
     #+end_src
 2)
     #+begin_src shell
ps -eo pid,args |grep 'try-main' | cut -f1 -d' '| head -1 | xargs kill -HUP
     #+end_src

 That's important as we now have a way to modify and kill/restart things. Yeah!

 A little bit further before we ~fork()~ around.

*** ~first-hello~ Executable

This is quite simple. Essentially we need to prepare, on gerbil's side, the
variables ~argc~ and ~argv~ from a ~(main . args)~ function.

The only reason it's simple is this part comes after the figuring out of how to
do just that. The details are in the first [[#firstHelloExec][~opt.ss~ and ~fuse_opt.h~]] that
follows.

#+begin_src scheme :tangle ./examples/first-hello.ss :noweb yes
(export (import: ../opt) main)
(import :std/foreign :gerbil/gambit/foreign ../opt)

(def (main . args) (%main (fuse_args<-list ["first-hello" args ...])))
(begin-ffi (%main fuse_args*)
  (c-declare "#include \"hello.c\"")
  (c-declare "#include <fuse_opt.h>")
  (define-c-struct fuse_args)
  (define-c-lambda %main (fuse_args*) int "
int res = _main(___arg1->argc, ___arg1->argv);
___return(res);"))
#+end_src

That creates a binary that, when dynmaically loading gerbil/gambit objects,
works great!

#+begin_src shell
$ sudo GERBIL_PATH=$HOME/.gerbil ./bin/first-hello \
         --name="hello-gerbil" --contents=$'Gerbil Noise!\n' -o allow_other /tmp/gfuse-test
hello: This is main! first-hello
$ ls /tmp/gfuse-test/
hello-gerbil
$ cat /tmp/gfuse-test/hello-gerbil
Gerbil Noise!
$ sudo umount /tmp/gfuse-test
$ ls /tmp/gfuse-test/
$
#+end_src


**** ~opt.ss~ and ~fuse_opt.h~
:PROPERTIES:
:CUSTOM_ID: firstHelloExec
:END:


This time we need some C fsckery. We need to create our own ~argc~ and ~argv~ to
pass to main.

The "easy" way is to use what FUSE provides and build on that.

We'll make an FFI struct!


#+begin_quote
#include <fuse_opt.h>

Data Fields
  int 	argc
  char ** 	argv
  int 	allocated
#+end_quote

In gerbil. The free function is in ~_main()~ as well so there you go.

#+begin_src scheme :noweb-ref fuse_args
(c-declare "___SCMOBJ fuse_opt_ffi_free_args (void *ptr) {
     fuse_opt_free_args(ptr);
     return ___FIX (___NO_ERR);
    };
")

(define-c-struct fuse_args
  ((argc . int)
   (argv . (pointer char-string))
   (allocated . int))
  "fuse_opt_ffi_free_args")
;;(c-define-type fuse_args (struct "fuse_args"))
;;(c-define-type fuse_args* (pointer fuse_args))
#+end_src

At the bottom of the ~hello.c~ file there's an init. We'l crib that and malloc
on the heap. We need at least one in the ~argv~ which makes sense if you know
*POSIX*.


#+begin_src c :noweb-ref emulate argv
char *argv[] = {
   ___arg1,
   NULL
};
#+end_src

Make it heapy.

#+begin_src c :noweb-ref struct args
struct fuse_args stack_args = FUSE_ARGS_INIT(1, argv);
struct fuse_args *heap_args;
heap_args = (struct fuse_args *) malloc(sizeof(struct fuse_args));
,*heap_args = stack_args;

#+end_src

And create an init function that does just that.

#+begin_src scheme :noweb yes :noweb-ref fuse_args_init
(define-c-lambda %FUSE_ARGS_INIT (char-string) fuse_args* #<<EOF
  <<emulate argv>>
  <<struct args>>

	/* This seems to be what is needed to init and allocate. */
	if (fuse_opt_parse(heap_args, NULL, NULL, NULL) == -1) {
		___return(NULL);   };
  ___return(heap_args);
EOF
)
#+end_src

How about some ~fuse_arg-ref~'s?

#+begin_src scheme :noweb-ref %fuse_args-ref
(define-c-lambda %fuse_args-ref (fuse_args* int) char-string
  "char* ret = ___arg1->argv[___arg2];
___return(ret);")
#+end_src

#+begin_src scheme :noweb-ref fuse_args-ref
(def (fuse_args-ref fas n)
  (let (limit (fuse_args-argc fas))
    (and (> limit n) (%fuse_args-ref fas n))))

#+end_src

There are now two functions we should FFI with.

First there's ~fuse_opt_insert_arg~ which we'll turn into ~fuse_args-ref-set!~.

#+begin_src scheme :noweb-ref fuse_args-ref
(def (fuse_args-ref-set! fas n v)
  (let (limit (fuse_args-argc fas))
    (if (> n limit) (error "arg index Out of range: ~a >= ~a "
                       n limit)
        (fuse_opt_insert_arg fas n v))))
#+end_src

#+begin_src scheme :noweb-ref fuse_opt_insert_arg
(define-c-lambda fuse_opt_insert_arg (fuse_args* int char-string) int
  "fuse_opt_insert_arg")
#+end_src

There's also ~fuse_opt_add_arg~ which we don't actually require as ~fuse_opt_insert_arg~ calls it but it does make it clear.

#+begin_src scheme :noweb-ref fuse_opt_add_arg
(define-c-lambda fuse_opt_add_arg (fuse_args* char-string) int
  "fuse_opt_add_arg")
#+end_src

Using them we can make a ~fuse_args<-list~ constructor. Aliased as ~list->fuse_args~ for those forwards people.

#+begin_src scheme :noweb-ref fuse_args<-list
(def (fuse_args<-list lst)
  (def fas (%FUSE_ARGS_INIT (car lst)))
  (def n 1)
  (for-each (lambda (fa)
              (set! (fuse_args-ref fas n) fa)
              (set! n (1+ n)))
            (cdr lst))
  fas)
(defalias list->fuse_args fuse_args<-list)
#+end_src

Now just to confuse those forwards thinkers that think end is the result, ~list<-fuse_args~ and ~fuse_args->list~.

#+begin_src scheme :noweb-ref fuse_args->list
(def (fuse_args->list fas)
  (def limit (fuse_args-argc fas))
  (let lst ((n 0))
    (if (= n limit) []
        (cons (fuse_args-ref fas n) (lst (1+ n))))))
(defalias list<-fuse_args fuse_args->list)
#+end_src

It's important to note that our ~set!~ does not modify but rather appends or
prepends at ~pos~.

#+begin_quote
◆ fuse_opt_insert_arg()

int fuse_opt_insert_arg	(
  struct fuse_args * 	args,
  int 	pos,
  const char * 	arg
)

Add an argument at the specified position in a NULL terminated argument vector

Adds the argument to the N-th position. This is useful for adding options at the
beginning of the array which must not come after the special '–' option.

Parameters
  - args	is the structure containing the current argument list
  - pos	is the position at which to add the argument
  - arg	is the new argument to add
Returns
-1 on allocation error, 0 on success
#+end_quote

Keeping that in mind it works.

#+begin_src scheme
> (def args ["car" "-d" "-o" "allow_other" "/tmp/gfuse-test"])
> (def fas (fuse_args<-list args))
> (list<-fuse_args fas)
("car" "-d" "-o" "allow_other" "/tmp/gfuse-test")
#+end_src

***** /File/ ~opt.ss~

All of those things can be placed in a file that will grow to have most of ~fuse_opt.h~ translated.

#+begin_src scheme :tangle ./opt.ss :noweb yes
(export
  %FUSE_ARGS_INIT
  fuse_args
  fuse_args*
  fuse_args-argc
  fuse_args-argv
  fuse_args-allocated
  fuse_args-ref
  fuse_args-ref-set!
  fuse_opt_insert_arg
  fuse_opt_add_arg
  fuse_args<-list list->fuse_args
  fuse_args->list list<-fuse_args)
(import :std/foreign :gerbil/gambit/foreign)

<<fuse_args-ref>>

<<fuse_args->list>>

<<fuse_args<-list>>

(begin-ffi
    (%FUSE_ARGS_INIT
     fuse_opt_add_arg
     %fuse_args-ref
     fuse_opt_insert_arg
     fuse_args fuse_args* (struct fuse_args argc argv allocated)
     )
  (c-declare "#include <fuse_opt.h>")

  <<fuse_args>>

<<fuse_args_init>>

  <<fuse_opt_insert_arg>>

  <<%fuse_args-ref>>)

#+end_src


*** /File/ ~examples/hello.c~

#+begin_src c :tangle ./examples/hello.c
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU GPLv2.
  See the file COPYING.
,*/

/** @file
 ,*
 ,* minimal example filesystem using high-level API
 ,*
 ,* Compile with:
 ,*
 ,*     gcc -Wall hello.c `pkg-config fuse3 --cflags --libs` -o hello
 ,*
 ,* ## Source code ##
 ,* \include hello.c
 ,*/


#define FUSE_USE_VERSION 31

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <assert.h>

/*
 ,* Command line options
 ,*
 ,* We can't set default values for the char* fields here because
 ,* fuse_opt_parse would attempt to free() them when the user specifies
 ,* different values on the command line.
 ,*/
static struct options {
	const char *filename;
	const char *contents;
	int show_help;
} options;

#define OPTION(t, p)                           \
    { t, offsetof(struct options, p), 1 }
static const struct fuse_opt option_spec[] = {
	OPTION("--name=%s", filename),
	OPTION("--contents=%s", contents),
	OPTION("-h", show_help),
	OPTION("--help", show_help),
	FUSE_OPT_END
};

static void *hello_init(struct fuse_conn_info *conn,
			struct fuse_config *cfg)
{
	(void) conn;
cfg->kernel_cache = 1;
	return NULL;
}

static int hello_getattr(const char *path, struct stat *stbuf,
			 struct fuse_file_info *fi)
{
	(void) fi;
	int res = 0;

	memset(stbuf, 0, sizeof(struct stat));
	if (strcmp(path, "/") == 0) {
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 2;
	} else if (strcmp(path+1, options.filename) == 0) {
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = strlen(options.contents);
	} else
		res = -ENOENT;

	return res;
}

static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
			 off_t offset, struct fuse_file_info *fi,
			 enum fuse_readdir_flags flags)
{
	(void) offset;
	(void) fi;
	(void) flags;

	if (strcmp(path, "/") != 0)
		return -ENOENT;

	filler(buf, ".", NULL, 0, 0);
	filler(buf, "..", NULL, 0, 0);
	filler(buf, options.filename, NULL, 0, 0);

	return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi)
{
	if (strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	if ((fi->flags & O_ACCMODE) != O_RDONLY)
		return -EACCES;

	return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset,
		      struct fuse_file_info *fi)
{
	size_t len;
	(void) fi;
	if(strcmp(path+1, options.filename) != 0)
		return -ENOENT;

	len = strlen(options.contents);
	if (offset < len) {
		if (offset + size > len)
			size = len - offset;
		memcpy(buf, options.contents + offset, size);
	} else
		size = 0;

	return size;
}

static const struct fuse_operations hello_oper = {
	.init           = hello_init,
	.getattr	= hello_getattr,
	.readdir	= hello_readdir,
	.open		= hello_open,
	.read		= hello_read,
};

static void show_help(const char *progname)
{
	printf("usage: %s [options] <mountpoint>\n\n", progname);
	printf("File-system specific options:\n"
	       "    --name=<s>          Name of the \"hello\" file\n"
	       "                        (default: \"hello\")\n"
	       "    --contents=<s>      Contents \"hello\" file\n"
	       "                        (default \"Hello, World!\\n\")\n"
	       "\n");
}

int _main(int argc, char *argv[])
{
	int ret;
	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);

	/* Set defaults -- we have to use strdup so that
	   fuse_opt_parse can free the defaults if other
	   values are specified */
	options.filename = strdup("hello");
	options.contents = strdup("Hello World!\n");


	/* Parse options */
	if (fuse_opt_parse(&args, &options, option_spec, NULL) == -1) {
		return 1;
    }

  fprintf(stderr, "hello: This is main! %s\n", argv[0]);
	/* When --help is specified, first print our own file-system
	   specific help text, then signal fuse_main to show
	   additional help (by adding `--help` to the options again)
	   without usage: line (by setting argv[0] to the empty
	   string) */
	if (options.show_help) {
		show_help(argv[0]);
		assert(fuse_opt_add_arg(&args, "--help") == 0);
		args.argv[0][0] = '\0';
	}

	ret = fuse_main(args.argc, args.argv, &hello_oper, NULL);
	fuse_opt_free_args(&args);
	return ret;
}


int main(int argc, char *argv[]) { int ret = _main(argc, argv); return ret; }
#+end_src


** The ~c2ffi~ generator

#+begin_src c :tangle gfuse.h
#define FUSE_USE_VERSION 31

#include <fuse.h>
#+end_src

#+begin_src shell :tangle ./bin/c2ffi-libfuse :shebang #!/usr/bin/env bash
_file=${1:-"c2ffi-libfuse.ss"}
_h=${1:-"gfuse.h"}

echo '(export #t)' > $_file

_cfile=`mktemp`
_fusedir=$(pkg-config --cflags-only-I fuse3 | sed 's/^-I//g')

echo "(def c2ffi-libfuse '(" >> $_file

c2ffi -D sexp -i "$_fusedir" $_h >> $_file
echo "))" >> $_file
#+end_src

#+RESULTS:

* Gerbil lib

#+begin_src gerbil :tangle gerbil.pkg
(package: drewc/fuse)
#+end_src

#+begin_src gerbil :tangle build.ss :shebang #!/usr/bin/env gxi
(import :std/build-script :std/make
        :gerbil/gambit/ports)

(def libs "fuse3")
(def gerbil-path (getenv "GERBIL_PATH" "~/.gerbil"))
(def libdir (path-expand "lib" gerbil-path))
(def bindir (path-expand "bin" gerbil-path))
(def statdir (path-expand "static" libdir))

(def (fgxc fn . rest)
  (cons*
   gxc: fn
   "-cc-options"
   (pkg-config-cflags libs)
   "-ld-options"
   (pkg-config-libs libs)
   rest))

(def (force-outputs) (force-output (current-error-port)) (force-output))
(def (message . lst) (apply displayln lst) (force-outputs))

(def (copy-compiled file)
  (def libpath (path-expand (string-append "drewc/fuse/" file) libdir))
  (create-directory* (path-directory libpath))
  (message "... copy " file " to " libpath)

  (when (file-exists? libpath)
    (delete-file libpath))
  (copy-file file libpath))

(def (copy-static file)
  (def spath (path-expand file statdir))
  (def fpath (path-expand file (path-expand "static/" (path-directory (this-source-file)))))
  (message "... copy static include " file)
  (when (file-exists? spath)
    (delete-file spath))
  (copy-file fpath spath))

(def (premade path)
  (def posts
    '("__0.o1"
      "__rt.o1"
      ".ssi"
      ".ssxi.ss"))
  (def files (map (cut string-append path <>) posts))

  (map (cut copy-compiled <>) files))

(def (make-clean)
  (shell-command "find . -name '*__*.o*' -exec rm -v {} \\;")
  (shell-command "find . -name '*.ssi' -exec rm -v {} \\;")
  (shell-command "find . -name '*.ssxi.ss' -exec rm -v {} \\;")
  (shell-command "find . -type d -name 'static' -exec rm -rv {} \\;"))

(def (local-build)
  (defbuild-script
  `(; "c2ffi-libfuse"
    ,(fgxc "opt")
    ,(fgxc "examples/try-main-hello")
    ,(fgxc "examples/first-hello")
    ;,(fgxc "examples/first-hello-exe")
    #;(gxc: "libfuse"
    "-cc-options"
    ,(pkg-config-cflags libs)
    "-ld-options"
    ,(pkg-config-libs libs)
    )
    )
  verbose: 1
  libdir: (path-directory (this-source-file)))
  (main))

(def (build-exes)
  (defbuild-script
    `((exe: ,@(cdr (fgxc "examples/first-hello"))))
    verbose: 1
    libdir: (path-directory (this-source-file))
    bindir: (path-expand "bin/" (path-directory (this-source-file))))
  (main))

(def (make-install)
 (premade "opt")
 (premade "examples/try-main-hello")
 (premade "examples/first-hello")
; (premade "examples/first-hello-exe")
 (for-each copy-static
           (directory-files (path-expand "static/" (path-directory (this-source-file))))))


(def (main . args)
  (if (and (pair? args) (equal? (car args) "clean"))
    (make-clean)
    (begin
      (make-clean)
      (local-build)
      (make-install)
      (build-exes)
      (make-install)
      )))

#+end_src
#+begin_src
#+end_src
